Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID globalTable SEMICOLON programVars programFunc main
Rule 2     globalTable -> <empty>
Rule 3     main -> mainTable MAIN LEFTPAR RIGHTPAR LEFTBRACE declaration statement RIGHTBRACE
Rule 4     mainTable -> <empty>
Rule 5     programVars -> globalDeclaration
Rule 6     programVars -> <empty>
Rule 7     globalDeclaration -> VAR declarationPDT
Rule 8     programFunc -> function programFunc
Rule 9     programFunc -> <empty>
Rule 10    assignment -> ID EQUAL Expression2 SEMICOLON
Rule 11    declaration -> VAR declarationPDT
Rule 12    declarationPDT -> PDT vars SEMICOLON declarationPDT
Rule 13    declarationPDT -> <empty>
Rule 14    PDT -> INT
Rule 15    PDT -> FLOAT
Rule 16    PDT -> CHAR
Rule 17    return -> RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
Rule 18    if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
Rule 19    createJQif -> <empty>
Rule 20    updateJQ -> <empty>
Rule 21    ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE
Rule 22    ifElse -> <empty>
Rule 23    createJQelse -> <empty>
Rule 24    for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
Rule 25    pushJumpFor -> <empty>
Rule 26    createQuadFor -> <empty>
Rule 27    updateQuadFor -> <empty>
Rule 28    forAssignment -> ID EQUAL CST_INT
Rule 29    pushLoop -> <empty>
Rule 30    startLoop -> <empty>
Rule 31    endLoop -> <empty>
Rule 32    comment -> COMMENT_TEXT
Rule 33    while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop
Rule 34    vars -> ID addVarsToTable varsArray varsComa
Rule 35    addVarsToTable -> <empty>
Rule 36    varsComa -> COMA vars
Rule 37    varsComa -> <empty>
Rule 38    varsMatrix -> LEFTBRACK CST_INT RIGHTBRACK
Rule 39    varsMatrix -> <empty>
Rule 40    varsArray -> LEFTBRACK CST_INT RIGHTBRACK varsMatrix
Rule 41    varsArray -> <empty>
Rule 42    function -> functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE
Rule 43    param -> PDT ID addFuncParams functionParam
Rule 44    param -> <empty>
Rule 45    functionParam -> COMA param
Rule 46    functionParam -> <empty>
Rule 47    addFuncParams -> <empty>
Rule 48    setParamLength -> <empty>
Rule 49    functionType -> FUNCTION PDT
Rule 50    functionType -> FUNCTION VOID setVoidType
Rule 51    cst_PDT -> CST_INT addTypeInt
Rule 52    cst_PDT -> CST_FLOAT addTypeFloat
Rule 53    cst_PDT -> CST_CHAR addTypeChar
Rule 54    addTypeInt -> <empty>
Rule 55    addTypeFloat -> <empty>
Rule 56    addTypeChar -> <empty>
Rule 57    addFuncToDir -> <empty>
Rule 58    Expression2 -> Expression3 evaluateExp2 Expression22 Expression2Nested
Rule 59    Expression2 -> Expression3 opMatrix
Rule 60    Expression2 -> Expression3 evaluateExp2
Rule 61    Expression2Nested -> Expression3 evaluateExp2 Expression22 Expression2Nested
Rule 62    Expression2Nested -> Expression3 evaluateExp2
Rule 63    evaluateExp2 -> <empty>
Rule 64    Expression22 -> AND addOperator
Rule 65    Expression22 -> OR addOperator
Rule 66    Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3
Rule 67    Expression3 -> exp evaluateExp3
Rule 68    Expression33 -> GT addOperator
Rule 69    Expression33 -> LT addOperator
Rule 70    Expression33 -> NOTEQUAL addOperator
Rule 71    Expression33 -> ISEQUAL addOperator
Rule 72    evaluateExp3 -> <empty>
Rule 73    opMatrix -> EXCLAMATION addOperator
Rule 74    opMatrix -> QUESTION addOperator
Rule 75    opMatrix -> DOLLARSIGN addOperator
Rule 76    exp -> term evaluateTerm expFunction
Rule 77    exp -> term evaluateTerm
Rule 78    evaluateTerm -> <empty>
Rule 79    expFunction -> PLUS addOperator exp
Rule 80    expFunction -> MINUS addOperator exp
Rule 81    setVoidType -> <empty>
Rule 82    term -> factor evaluateFactor termFunction
Rule 83    term -> factor evaluateFactor
Rule 84    evaluateFactor -> <empty>
Rule 85    termFunction -> MULTIPLY addOperator term
Rule 86    termFunction -> DIVIDE addOperator term
Rule 87    addOperator -> <empty>
Rule 88    factor -> LEFTPAR Expression2 RIGHTPAR
Rule 89    factor -> cst_PDT addOperandCst
Rule 90    factor -> module
Rule 91    factor -> ID addOperandId addTypeId
Rule 92    addTypeId -> <empty>
Rule 93    addOperandCst -> <empty>
Rule 94    addOperandId -> <empty>
Rule 95    read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON
Rule 96    id_list -> ID addRead id_listFunction
Rule 97    id_listFunction -> COMA id_list
Rule 98    id_listFunction -> <empty>
Rule 99    addRead -> <empty>
Rule 100   print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
Rule 101   printFunction -> print_param COMA printFunction2
Rule 102   printFunction -> print_param
Rule 103   printFunction2 -> printFunction
Rule 104   addPrint -> <empty>
Rule 105   print_param -> Expression2 addPrint
Rule 106   print_param -> CST_STRING addPrintString
Rule 107   addPrintString -> <empty>
Rule 108   module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
Rule 109   checkFunctionExists -> <empty>
Rule 110   generateERASize -> <empty>
Rule 111   nullParam -> <empty>
Rule 112   generateGosub -> <empty>
Rule 113   generateParam -> <empty>
Rule 114   nextParam -> <empty>
Rule 115   statement -> return
Rule 116   statement -> if statement
Rule 117   statement -> comment statement
Rule 118   statement -> read statement
Rule 119   statement -> print statement
Rule 120   statement -> assignment statement
Rule 121   statement -> module statement
Rule 122   statement -> for statement
Rule 123   statement -> while statement
Rule 124   statement -> <empty>
Rule 125   moduleFunction -> Expression2 generateParam nextParam COMA moduleFunction
Rule 126   moduleFunction -> Expression2 generateParam
Rule 127   moduleFunction -> <empty>

Terminals, with rules where they appear

AND                  : 64
CHAR                 : 16
COMA                 : 36 45 97 101 125
COMMENT_TEXT         : 32
CST_CHAR             : 53
CST_FLOAT            : 52
CST_INT              : 28 38 40 51
CST_STRING           : 106
DIVIDE               : 86
DOLLARSIGN           : 75
ELSE                 : 21
EQUAL                : 10 28
EXCLAMATION          : 73
FLOAT                : 15
FOR                  : 24
FUNCTION             : 49 50
GT                   : 68
ID                   : 1 10 28 34 42 43 91 96 108
IF                   : 18
INT                  : 14
ISEQUAL              : 71
LEFTBRACE            : 3 18 21 24 33 42
LEFTBRACK            : 38 40
LEFTPAR              : 3 17 18 33 42 88 95 100 108
LT                   : 69
MAIN                 : 3
MINUS                : 80
MULTIPLY             : 85
NOTEQUAL             : 70
OR                   : 65
PLUS                 : 79
PRINT                : 100
PROGRAM              : 1
QUESTION             : 74
READ                 : 95
RETURN               : 17
RIGHTBRACE           : 3 18 21 24 33 42
RIGHTBRACK           : 38 40
RIGHTPAR             : 3 17 18 33 42 88 95 100 108
SEMICOLON            : 1 10 12 17 95 100 108
THEN                 : 18
TO                   : 24
VAR                  : 7 11
VOID                 : 50
WHILE                : 33
error                : 

Nonterminals, with rules where they appear

Expression2          : 10 17 18 24 33 88 105 125 126
Expression22         : 58 61
Expression2Nested    : 58 61
Expression3          : 58 59 60 61 62
Expression33         : 66
PDT                  : 12 43 49
addFuncParams        : 43
addFuncToDir         : 42
addOperandCst        : 89
addOperandId         : 91
addOperator          : 64 65 68 69 70 71 73 74 75 79 80 85 86
addPrint             : 105
addPrintString       : 106
addRead              : 96
addTypeChar          : 53
addTypeFloat         : 52
addTypeId            : 91
addTypeInt           : 51
addVarsToTable       : 34
assignment           : 120
checkFunctionExists  : 108
comment              : 117
createJQelse         : 21
createJQif           : 18
createQuadFor        : 24
cst_PDT              : 89
declaration          : 3 42
declarationPDT       : 7 11 12
endLoop              : 33
evaluateExp2         : 58 60 61 62
evaluateExp3         : 66 66 67
evaluateFactor       : 82 83
evaluateTerm         : 76 77
exp                  : 66 66 67 79 80
expFunction          : 76
factor               : 82 83
for                  : 122
forAssignment        : 24
function             : 8
functionParam        : 43
functionType         : 42
generateERASize      : 108
generateGosub        : 108
generateParam        : 125 126
globalDeclaration    : 5
globalTable          : 1
id_list              : 95 97
id_listFunction      : 96
if                   : 116
ifElse               : 18
main                 : 1
mainTable            : 3
module               : 90 121
moduleFunction       : 108 125
nextParam            : 125
nullParam            : 108
opMatrix             : 59
param                : 42 45
print                : 119
printFunction        : 100 103
printFunction2       : 101
print_param          : 101 102
program              : 0
programFunc          : 1 8
programVars          : 1
pushJumpFor          : 24
pushLoop             : 33
read                 : 118
return               : 115
setParamLength       : 42
setVoidType          : 50
startLoop            : 33
statement            : 3 18 21 24 33 42 116 117 118 119 120 121 122 123
term                 : 76 77 85 86
termFunction         : 82
updateJQ             : 18
updateQuadFor        : 24
vars                 : 12 36
varsArray            : 34
varsComa             : 34
varsMatrix           : 40
while                : 123

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID globalTable SEMICOLON programVars programFunc main

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID globalTable SEMICOLON programVars programFunc main

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . globalTable SEMICOLON programVars programFunc main
    (2) globalTable -> .

    SEMICOLON       reduce using rule 2 (globalTable -> .)

    globalTable                    shift and go to state 4

state 4

    (1) program -> PROGRAM ID globalTable . SEMICOLON programVars programFunc main

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID globalTable SEMICOLON . programVars programFunc main
    (5) programVars -> . globalDeclaration
    (6) programVars -> .
    (7) globalDeclaration -> . VAR declarationPDT

    FUNCTION        reduce using rule 6 (programVars -> .)
    MAIN            reduce using rule 6 (programVars -> .)
    VAR             shift and go to state 8

    programVars                    shift and go to state 6
    globalDeclaration              shift and go to state 7

state 6

    (1) program -> PROGRAM ID globalTable SEMICOLON programVars . programFunc main
    (8) programFunc -> . function programFunc
    (9) programFunc -> .
    (42) function -> . functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE
    (49) functionType -> . FUNCTION PDT
    (50) functionType -> . FUNCTION VOID setVoidType

    MAIN            reduce using rule 9 (programFunc -> .)
    FUNCTION        shift and go to state 12

    programFunc                    shift and go to state 9
    function                       shift and go to state 10
    functionType                   shift and go to state 11

state 7

    (5) programVars -> globalDeclaration .

    FUNCTION        reduce using rule 5 (programVars -> globalDeclaration .)
    MAIN            reduce using rule 5 (programVars -> globalDeclaration .)


state 8

    (7) globalDeclaration -> VAR . declarationPDT
    (12) declarationPDT -> . PDT vars SEMICOLON declarationPDT
    (13) declarationPDT -> .
    (14) PDT -> . INT
    (15) PDT -> . FLOAT
    (16) PDT -> . CHAR

    FUNCTION        reduce using rule 13 (declarationPDT -> .)
    MAIN            reduce using rule 13 (declarationPDT -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    declarationPDT                 shift and go to state 13
    PDT                            shift and go to state 14

state 9

    (1) program -> PROGRAM ID globalTable SEMICOLON programVars programFunc . main
    (3) main -> . mainTable MAIN LEFTPAR RIGHTPAR LEFTBRACE declaration statement RIGHTBRACE
    (4) mainTable -> .

    MAIN            reduce using rule 4 (mainTable -> .)

    main                           shift and go to state 18
    mainTable                      shift and go to state 19

state 10

    (8) programFunc -> function . programFunc
    (8) programFunc -> . function programFunc
    (9) programFunc -> .
    (42) function -> . functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE
    (49) functionType -> . FUNCTION PDT
    (50) functionType -> . FUNCTION VOID setVoidType

    MAIN            reduce using rule 9 (programFunc -> .)
    FUNCTION        shift and go to state 12

    function                       shift and go to state 10
    programFunc                    shift and go to state 20
    functionType                   shift and go to state 11

state 11

    (42) function -> functionType . ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE

    ID              shift and go to state 21


state 12

    (49) functionType -> FUNCTION . PDT
    (50) functionType -> FUNCTION . VOID setVoidType
    (14) PDT -> . INT
    (15) PDT -> . FLOAT
    (16) PDT -> . CHAR

    VOID            shift and go to state 23
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    PDT                            shift and go to state 22

state 13

    (7) globalDeclaration -> VAR declarationPDT .

    FUNCTION        reduce using rule 7 (globalDeclaration -> VAR declarationPDT .)
    MAIN            reduce using rule 7 (globalDeclaration -> VAR declarationPDT .)


state 14

    (12) declarationPDT -> PDT . vars SEMICOLON declarationPDT
    (34) vars -> . ID addVarsToTable varsArray varsComa

    ID              shift and go to state 25

    vars                           shift and go to state 24

state 15

    (14) PDT -> INT .

    ID              reduce using rule 14 (PDT -> INT .)


state 16

    (15) PDT -> FLOAT .

    ID              reduce using rule 15 (PDT -> FLOAT .)


state 17

    (16) PDT -> CHAR .

    ID              reduce using rule 16 (PDT -> CHAR .)


state 18

    (1) program -> PROGRAM ID globalTable SEMICOLON programVars programFunc main .

    $end            reduce using rule 1 (program -> PROGRAM ID globalTable SEMICOLON programVars programFunc main .)


state 19

    (3) main -> mainTable . MAIN LEFTPAR RIGHTPAR LEFTBRACE declaration statement RIGHTBRACE

    MAIN            shift and go to state 26


state 20

    (8) programFunc -> function programFunc .

    MAIN            reduce using rule 8 (programFunc -> function programFunc .)


state 21

    (42) function -> functionType ID . addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE
    (57) addFuncToDir -> .

    LEFTPAR         reduce using rule 57 (addFuncToDir -> .)

    addFuncToDir                   shift and go to state 27

state 22

    (49) functionType -> FUNCTION PDT .

    ID              reduce using rule 49 (functionType -> FUNCTION PDT .)


state 23

    (50) functionType -> FUNCTION VOID . setVoidType
    (81) setVoidType -> .

    ID              reduce using rule 81 (setVoidType -> .)

    setVoidType                    shift and go to state 28

state 24

    (12) declarationPDT -> PDT vars . SEMICOLON declarationPDT

    SEMICOLON       shift and go to state 29


state 25

    (34) vars -> ID . addVarsToTable varsArray varsComa
    (35) addVarsToTable -> .

    LEFTBRACK       reduce using rule 35 (addVarsToTable -> .)
    COMA            reduce using rule 35 (addVarsToTable -> .)
    SEMICOLON       reduce using rule 35 (addVarsToTable -> .)

    addVarsToTable                 shift and go to state 30

state 26

    (3) main -> mainTable MAIN . LEFTPAR RIGHTPAR LEFTBRACE declaration statement RIGHTBRACE

    LEFTPAR         shift and go to state 31


state 27

    (42) function -> functionType ID addFuncToDir . LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE

    LEFTPAR         shift and go to state 32


state 28

    (50) functionType -> FUNCTION VOID setVoidType .

    ID              reduce using rule 50 (functionType -> FUNCTION VOID setVoidType .)


state 29

    (12) declarationPDT -> PDT vars SEMICOLON . declarationPDT
    (12) declarationPDT -> . PDT vars SEMICOLON declarationPDT
    (13) declarationPDT -> .
    (14) PDT -> . INT
    (15) PDT -> . FLOAT
    (16) PDT -> . CHAR

    FUNCTION        reduce using rule 13 (declarationPDT -> .)
    MAIN            reduce using rule 13 (declarationPDT -> .)
    RETURN          reduce using rule 13 (declarationPDT -> .)
    IF              reduce using rule 13 (declarationPDT -> .)
    COMMENT_TEXT    reduce using rule 13 (declarationPDT -> .)
    READ            reduce using rule 13 (declarationPDT -> .)
    PRINT           reduce using rule 13 (declarationPDT -> .)
    ID              reduce using rule 13 (declarationPDT -> .)
    FOR             reduce using rule 13 (declarationPDT -> .)
    WHILE           reduce using rule 13 (declarationPDT -> .)
    RIGHTBRACE      reduce using rule 13 (declarationPDT -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    PDT                            shift and go to state 14
    declarationPDT                 shift and go to state 33

state 30

    (34) vars -> ID addVarsToTable . varsArray varsComa
    (40) varsArray -> . LEFTBRACK CST_INT RIGHTBRACK varsMatrix
    (41) varsArray -> .

    LEFTBRACK       shift and go to state 35
    COMA            reduce using rule 41 (varsArray -> .)
    SEMICOLON       reduce using rule 41 (varsArray -> .)

    varsArray                      shift and go to state 34

state 31

    (3) main -> mainTable MAIN LEFTPAR . RIGHTPAR LEFTBRACE declaration statement RIGHTBRACE

    RIGHTPAR        shift and go to state 36


state 32

    (42) function -> functionType ID addFuncToDir LEFTPAR . param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE
    (43) param -> . PDT ID addFuncParams functionParam
    (44) param -> .
    (14) PDT -> . INT
    (15) PDT -> . FLOAT
    (16) PDT -> . CHAR

    RIGHTPAR        reduce using rule 44 (param -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    param                          shift and go to state 37
    PDT                            shift and go to state 38

state 33

    (12) declarationPDT -> PDT vars SEMICOLON declarationPDT .

    FUNCTION        reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    MAIN            reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    RETURN          reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    IF              reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    COMMENT_TEXT    reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    READ            reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    PRINT           reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    ID              reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    FOR             reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    WHILE           reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)
    RIGHTBRACE      reduce using rule 12 (declarationPDT -> PDT vars SEMICOLON declarationPDT .)


state 34

    (34) vars -> ID addVarsToTable varsArray . varsComa
    (36) varsComa -> . COMA vars
    (37) varsComa -> .

    COMA            shift and go to state 40
    SEMICOLON       reduce using rule 37 (varsComa -> .)

    varsComa                       shift and go to state 39

state 35

    (40) varsArray -> LEFTBRACK . CST_INT RIGHTBRACK varsMatrix

    CST_INT         shift and go to state 41


state 36

    (3) main -> mainTable MAIN LEFTPAR RIGHTPAR . LEFTBRACE declaration statement RIGHTBRACE

    LEFTBRACE       shift and go to state 42


state 37

    (42) function -> functionType ID addFuncToDir LEFTPAR param . RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE

    RIGHTPAR        shift and go to state 43


state 38

    (43) param -> PDT . ID addFuncParams functionParam

    ID              shift and go to state 44


state 39

    (34) vars -> ID addVarsToTable varsArray varsComa .

    SEMICOLON       reduce using rule 34 (vars -> ID addVarsToTable varsArray varsComa .)


state 40

    (36) varsComa -> COMA . vars
    (34) vars -> . ID addVarsToTable varsArray varsComa

    ID              shift and go to state 25

    vars                           shift and go to state 45

state 41

    (40) varsArray -> LEFTBRACK CST_INT . RIGHTBRACK varsMatrix

    RIGHTBRACK      shift and go to state 46


state 42

    (3) main -> mainTable MAIN LEFTPAR RIGHTPAR LEFTBRACE . declaration statement RIGHTBRACE
    (11) declaration -> . VAR declarationPDT

    VAR             shift and go to state 48

    declaration                    shift and go to state 47

state 43

    (42) function -> functionType ID addFuncToDir LEFTPAR param RIGHTPAR . setParamLength LEFTBRACE declaration statement RIGHTBRACE
    (48) setParamLength -> .

    LEFTBRACE       reduce using rule 48 (setParamLength -> .)

    setParamLength                 shift and go to state 49

state 44

    (43) param -> PDT ID . addFuncParams functionParam
    (47) addFuncParams -> .

    COMA            reduce using rule 47 (addFuncParams -> .)
    RIGHTPAR        reduce using rule 47 (addFuncParams -> .)

    addFuncParams                  shift and go to state 50

state 45

    (36) varsComa -> COMA vars .

    SEMICOLON       reduce using rule 36 (varsComa -> COMA vars .)


state 46

    (40) varsArray -> LEFTBRACK CST_INT RIGHTBRACK . varsMatrix
    (38) varsMatrix -> . LEFTBRACK CST_INT RIGHTBRACK
    (39) varsMatrix -> .

    LEFTBRACK       shift and go to state 51
    COMA            reduce using rule 39 (varsMatrix -> .)
    SEMICOLON       reduce using rule 39 (varsMatrix -> .)

    varsMatrix                     shift and go to state 52

state 47

    (3) main -> mainTable MAIN LEFTPAR RIGHTPAR LEFTBRACE declaration . statement RIGHTBRACE
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    statement                      shift and go to state 53
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 48

    (11) declaration -> VAR . declarationPDT
    (12) declarationPDT -> . PDT vars SEMICOLON declarationPDT
    (13) declarationPDT -> .
    (14) PDT -> . INT
    (15) PDT -> . FLOAT
    (16) PDT -> . CHAR

    RETURN          reduce using rule 13 (declarationPDT -> .)
    IF              reduce using rule 13 (declarationPDT -> .)
    COMMENT_TEXT    reduce using rule 13 (declarationPDT -> .)
    READ            reduce using rule 13 (declarationPDT -> .)
    PRINT           reduce using rule 13 (declarationPDT -> .)
    ID              reduce using rule 13 (declarationPDT -> .)
    FOR             reduce using rule 13 (declarationPDT -> .)
    WHILE           reduce using rule 13 (declarationPDT -> .)
    RIGHTBRACE      reduce using rule 13 (declarationPDT -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    declarationPDT                 shift and go to state 71
    PDT                            shift and go to state 14

state 49

    (42) function -> functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength . LEFTBRACE declaration statement RIGHTBRACE

    LEFTBRACE       shift and go to state 72


state 50

    (43) param -> PDT ID addFuncParams . functionParam
    (45) functionParam -> . COMA param
    (46) functionParam -> .

    COMA            shift and go to state 74
    RIGHTPAR        reduce using rule 46 (functionParam -> .)

    functionParam                  shift and go to state 73

state 51

    (38) varsMatrix -> LEFTBRACK . CST_INT RIGHTBRACK

    CST_INT         shift and go to state 75


state 52

    (40) varsArray -> LEFTBRACK CST_INT RIGHTBRACK varsMatrix .

    COMA            reduce using rule 40 (varsArray -> LEFTBRACK CST_INT RIGHTBRACK varsMatrix .)
    SEMICOLON       reduce using rule 40 (varsArray -> LEFTBRACK CST_INT RIGHTBRACK varsMatrix .)


state 53

    (3) main -> mainTable MAIN LEFTPAR RIGHTPAR LEFTBRACE declaration statement . RIGHTBRACE

    RIGHTBRACE      shift and go to state 76


state 54

    (115) statement -> return .

    RIGHTBRACE      reduce using rule 115 (statement -> return .)


state 55

    (116) statement -> if . statement
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    if                             shift and go to state 55
    statement                      shift and go to state 77
    return                         shift and go to state 54
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 56

    (117) statement -> comment . statement
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    comment                        shift and go to state 56
    statement                      shift and go to state 78
    return                         shift and go to state 54
    if                             shift and go to state 55
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 57

    (118) statement -> read . statement
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    read                           shift and go to state 57
    statement                      shift and go to state 79
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 58

    (119) statement -> print . statement
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    print                          shift and go to state 58
    statement                      shift and go to state 80
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 59

    (120) statement -> assignment . statement
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    assignment                     shift and go to state 59
    statement                      shift and go to state 81
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 60

    (121) statement -> module . statement
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    module                         shift and go to state 60
    statement                      shift and go to state 82
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    for                            shift and go to state 61
    while                          shift and go to state 62

state 61

    (122) statement -> for . statement
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    for                            shift and go to state 61
    statement                      shift and go to state 83
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    while                          shift and go to state 62

state 62

    (123) statement -> while . statement
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    while                          shift and go to state 62
    statement                      shift and go to state 84
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61

state 63

    (17) return -> RETURN . LEFTPAR Expression2 RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 85


state 64

    (18) if -> IF . LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ

    LEFTPAR         shift and go to state 86


state 65

    (32) comment -> COMMENT_TEXT .

    RETURN          reduce using rule 32 (comment -> COMMENT_TEXT .)
    IF              reduce using rule 32 (comment -> COMMENT_TEXT .)
    COMMENT_TEXT    reduce using rule 32 (comment -> COMMENT_TEXT .)
    READ            reduce using rule 32 (comment -> COMMENT_TEXT .)
    PRINT           reduce using rule 32 (comment -> COMMENT_TEXT .)
    ID              reduce using rule 32 (comment -> COMMENT_TEXT .)
    FOR             reduce using rule 32 (comment -> COMMENT_TEXT .)
    WHILE           reduce using rule 32 (comment -> COMMENT_TEXT .)
    RIGHTBRACE      reduce using rule 32 (comment -> COMMENT_TEXT .)


state 66

    (95) read -> READ . LEFTPAR id_list RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 87


state 67

    (100) print -> PRINT . LEFTPAR printFunction RIGHTPAR SEMICOLON

    LEFTPAR         shift and go to state 88


state 68

    (10) assignment -> ID . EQUAL Expression2 SEMICOLON
    (108) module -> ID . checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (109) checkFunctionExists -> .

    EQUAL           shift and go to state 89
    LEFTPAR         reduce using rule 109 (checkFunctionExists -> .)

    checkFunctionExists            shift and go to state 90

state 69

    (24) for -> FOR . forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (28) forAssignment -> . ID EQUAL CST_INT

    ID              shift and go to state 92

    forAssignment                  shift and go to state 91

state 70

    (33) while -> WHILE . pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop
    (29) pushLoop -> .

    LEFTPAR         reduce using rule 29 (pushLoop -> .)

    pushLoop                       shift and go to state 93

state 71

    (11) declaration -> VAR declarationPDT .

    RETURN          reduce using rule 11 (declaration -> VAR declarationPDT .)
    IF              reduce using rule 11 (declaration -> VAR declarationPDT .)
    COMMENT_TEXT    reduce using rule 11 (declaration -> VAR declarationPDT .)
    READ            reduce using rule 11 (declaration -> VAR declarationPDT .)
    PRINT           reduce using rule 11 (declaration -> VAR declarationPDT .)
    ID              reduce using rule 11 (declaration -> VAR declarationPDT .)
    FOR             reduce using rule 11 (declaration -> VAR declarationPDT .)
    WHILE           reduce using rule 11 (declaration -> VAR declarationPDT .)
    RIGHTBRACE      reduce using rule 11 (declaration -> VAR declarationPDT .)


state 72

    (42) function -> functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE . declaration statement RIGHTBRACE
    (11) declaration -> . VAR declarationPDT

    VAR             shift and go to state 48

    declaration                    shift and go to state 94

state 73

    (43) param -> PDT ID addFuncParams functionParam .

    RIGHTPAR        reduce using rule 43 (param -> PDT ID addFuncParams functionParam .)


state 74

    (45) functionParam -> COMA . param
    (43) param -> . PDT ID addFuncParams functionParam
    (44) param -> .
    (14) PDT -> . INT
    (15) PDT -> . FLOAT
    (16) PDT -> . CHAR

    RIGHTPAR        reduce using rule 44 (param -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    param                          shift and go to state 95
    PDT                            shift and go to state 38

state 75

    (38) varsMatrix -> LEFTBRACK CST_INT . RIGHTBRACK

    RIGHTBRACK      shift and go to state 96


state 76

    (3) main -> mainTable MAIN LEFTPAR RIGHTPAR LEFTBRACE declaration statement RIGHTBRACE .

    $end            reduce using rule 3 (main -> mainTable MAIN LEFTPAR RIGHTPAR LEFTBRACE declaration statement RIGHTBRACE .)


state 77

    (116) statement -> if statement .

    RIGHTBRACE      reduce using rule 116 (statement -> if statement .)


state 78

    (117) statement -> comment statement .

    RIGHTBRACE      reduce using rule 117 (statement -> comment statement .)


state 79

    (118) statement -> read statement .

    RIGHTBRACE      reduce using rule 118 (statement -> read statement .)


state 80

    (119) statement -> print statement .

    RIGHTBRACE      reduce using rule 119 (statement -> print statement .)


state 81

    (120) statement -> assignment statement .

    RIGHTBRACE      reduce using rule 120 (statement -> assignment statement .)


state 82

    (121) statement -> module statement .

    RIGHTBRACE      reduce using rule 121 (statement -> module statement .)


state 83

    (122) statement -> for statement .

    RIGHTBRACE      reduce using rule 122 (statement -> for statement .)


state 84

    (123) statement -> while statement .

    RIGHTBRACE      reduce using rule 123 (statement -> while statement .)


state 85

    (17) return -> RETURN LEFTPAR . Expression2 RIGHTPAR SEMICOLON
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    Expression2                    shift and go to state 98
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 86

    (18) if -> IF LEFTPAR . Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    Expression2                    shift and go to state 109
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 87

    (95) read -> READ LEFTPAR . id_list RIGHTPAR SEMICOLON
    (96) id_list -> . ID addRead id_listFunction

    ID              shift and go to state 111

    id_list                        shift and go to state 110

state 88

    (100) print -> PRINT LEFTPAR . printFunction RIGHTPAR SEMICOLON
    (101) printFunction -> . print_param COMA printFunction2
    (102) printFunction -> . print_param
    (105) print_param -> . Expression2 addPrint
    (106) print_param -> . CST_STRING addPrintString
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    CST_STRING      shift and go to state 115
    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    printFunction                  shift and go to state 112
    print_param                    shift and go to state 113
    Expression2                    shift and go to state 114
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 89

    (10) assignment -> ID EQUAL . Expression2 SEMICOLON
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    Expression2                    shift and go to state 116
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 90

    (108) module -> ID checkFunctionExists . generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (110) generateERASize -> .

    LEFTPAR         reduce using rule 110 (generateERASize -> .)

    generateERASize                shift and go to state 117

state 91

    (24) for -> FOR forAssignment . TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor

    TO              shift and go to state 118


state 92

    (28) forAssignment -> ID . EQUAL CST_INT

    EQUAL           shift and go to state 119


state 93

    (33) while -> WHILE pushLoop . LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    LEFTPAR         shift and go to state 120


state 94

    (42) function -> functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration . statement RIGHTBRACE
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    statement                      shift and go to state 121
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 95

    (45) functionParam -> COMA param .

    RIGHTPAR        reduce using rule 45 (functionParam -> COMA param .)


state 96

    (38) varsMatrix -> LEFTBRACK CST_INT RIGHTBRACK .

    COMA            reduce using rule 38 (varsMatrix -> LEFTBRACK CST_INT RIGHTBRACK .)
    SEMICOLON       reduce using rule 38 (varsMatrix -> LEFTBRACK CST_INT RIGHTBRACK .)


state 97

    (88) factor -> LEFTPAR . Expression2 RIGHTPAR
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    Expression2                    shift and go to state 122
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 98

    (17) return -> RETURN LEFTPAR Expression2 . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 123


state 99

    (58) Expression2 -> Expression3 . evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> Expression3 . opMatrix
    (60) Expression2 -> Expression3 . evaluateExp2
    (63) evaluateExp2 -> .
    (73) opMatrix -> . EXCLAMATION addOperator
    (74) opMatrix -> . QUESTION addOperator
    (75) opMatrix -> . DOLLARSIGN addOperator

    AND             reduce using rule 63 (evaluateExp2 -> .)
    OR              reduce using rule 63 (evaluateExp2 -> .)
    RIGHTPAR        reduce using rule 63 (evaluateExp2 -> .)
    COMA            reduce using rule 63 (evaluateExp2 -> .)
    SEMICOLON       reduce using rule 63 (evaluateExp2 -> .)
    LEFTBRACE       reduce using rule 63 (evaluateExp2 -> .)
    EXCLAMATION     shift and go to state 126
    QUESTION        shift and go to state 127
    DOLLARSIGN      shift and go to state 128

    evaluateExp2                   shift and go to state 124
    opMatrix                       shift and go to state 125

state 100

    (66) Expression3 -> exp . evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> exp . evaluateExp3
    (72) evaluateExp3 -> .

    GT              reduce using rule 72 (evaluateExp3 -> .)
    LT              reduce using rule 72 (evaluateExp3 -> .)
    NOTEQUAL        reduce using rule 72 (evaluateExp3 -> .)
    ISEQUAL         reduce using rule 72 (evaluateExp3 -> .)
    EXCLAMATION     reduce using rule 72 (evaluateExp3 -> .)
    QUESTION        reduce using rule 72 (evaluateExp3 -> .)
    DOLLARSIGN      reduce using rule 72 (evaluateExp3 -> .)
    AND             reduce using rule 72 (evaluateExp3 -> .)
    OR              reduce using rule 72 (evaluateExp3 -> .)
    RIGHTPAR        reduce using rule 72 (evaluateExp3 -> .)
    COMA            reduce using rule 72 (evaluateExp3 -> .)
    SEMICOLON       reduce using rule 72 (evaluateExp3 -> .)
    LEFTBRACE       reduce using rule 72 (evaluateExp3 -> .)

    evaluateExp3                   shift and go to state 129

state 101

    (76) exp -> term . evaluateTerm expFunction
    (77) exp -> term . evaluateTerm
    (78) evaluateTerm -> .

    PLUS            reduce using rule 78 (evaluateTerm -> .)
    MINUS           reduce using rule 78 (evaluateTerm -> .)
    GT              reduce using rule 78 (evaluateTerm -> .)
    LT              reduce using rule 78 (evaluateTerm -> .)
    NOTEQUAL        reduce using rule 78 (evaluateTerm -> .)
    ISEQUAL         reduce using rule 78 (evaluateTerm -> .)
    EXCLAMATION     reduce using rule 78 (evaluateTerm -> .)
    QUESTION        reduce using rule 78 (evaluateTerm -> .)
    DOLLARSIGN      reduce using rule 78 (evaluateTerm -> .)
    AND             reduce using rule 78 (evaluateTerm -> .)
    OR              reduce using rule 78 (evaluateTerm -> .)
    RIGHTPAR        reduce using rule 78 (evaluateTerm -> .)
    COMA            reduce using rule 78 (evaluateTerm -> .)
    SEMICOLON       reduce using rule 78 (evaluateTerm -> .)
    LEFTBRACE       reduce using rule 78 (evaluateTerm -> .)

    evaluateTerm                   shift and go to state 130

state 102

    (82) term -> factor . evaluateFactor termFunction
    (83) term -> factor . evaluateFactor
    (84) evaluateFactor -> .

    MULTIPLY        reduce using rule 84 (evaluateFactor -> .)
    DIVIDE          reduce using rule 84 (evaluateFactor -> .)
    PLUS            reduce using rule 84 (evaluateFactor -> .)
    MINUS           reduce using rule 84 (evaluateFactor -> .)
    GT              reduce using rule 84 (evaluateFactor -> .)
    LT              reduce using rule 84 (evaluateFactor -> .)
    NOTEQUAL        reduce using rule 84 (evaluateFactor -> .)
    ISEQUAL         reduce using rule 84 (evaluateFactor -> .)
    EXCLAMATION     reduce using rule 84 (evaluateFactor -> .)
    QUESTION        reduce using rule 84 (evaluateFactor -> .)
    DOLLARSIGN      reduce using rule 84 (evaluateFactor -> .)
    AND             reduce using rule 84 (evaluateFactor -> .)
    OR              reduce using rule 84 (evaluateFactor -> .)
    RIGHTPAR        reduce using rule 84 (evaluateFactor -> .)
    COMA            reduce using rule 84 (evaluateFactor -> .)
    SEMICOLON       reduce using rule 84 (evaluateFactor -> .)
    LEFTBRACE       reduce using rule 84 (evaluateFactor -> .)

    evaluateFactor                 shift and go to state 131

state 103

    (89) factor -> cst_PDT . addOperandCst
    (93) addOperandCst -> .

    MULTIPLY        reduce using rule 93 (addOperandCst -> .)
    DIVIDE          reduce using rule 93 (addOperandCst -> .)
    PLUS            reduce using rule 93 (addOperandCst -> .)
    MINUS           reduce using rule 93 (addOperandCst -> .)
    GT              reduce using rule 93 (addOperandCst -> .)
    LT              reduce using rule 93 (addOperandCst -> .)
    NOTEQUAL        reduce using rule 93 (addOperandCst -> .)
    ISEQUAL         reduce using rule 93 (addOperandCst -> .)
    EXCLAMATION     reduce using rule 93 (addOperandCst -> .)
    QUESTION        reduce using rule 93 (addOperandCst -> .)
    DOLLARSIGN      reduce using rule 93 (addOperandCst -> .)
    AND             reduce using rule 93 (addOperandCst -> .)
    OR              reduce using rule 93 (addOperandCst -> .)
    RIGHTPAR        reduce using rule 93 (addOperandCst -> .)
    COMA            reduce using rule 93 (addOperandCst -> .)
    SEMICOLON       reduce using rule 93 (addOperandCst -> .)
    LEFTBRACE       reduce using rule 93 (addOperandCst -> .)

    addOperandCst                  shift and go to state 132

state 104

    (90) factor -> module .

    MULTIPLY        reduce using rule 90 (factor -> module .)
    DIVIDE          reduce using rule 90 (factor -> module .)
    PLUS            reduce using rule 90 (factor -> module .)
    MINUS           reduce using rule 90 (factor -> module .)
    GT              reduce using rule 90 (factor -> module .)
    LT              reduce using rule 90 (factor -> module .)
    NOTEQUAL        reduce using rule 90 (factor -> module .)
    ISEQUAL         reduce using rule 90 (factor -> module .)
    EXCLAMATION     reduce using rule 90 (factor -> module .)
    QUESTION        reduce using rule 90 (factor -> module .)
    DOLLARSIGN      reduce using rule 90 (factor -> module .)
    AND             reduce using rule 90 (factor -> module .)
    OR              reduce using rule 90 (factor -> module .)
    RIGHTPAR        reduce using rule 90 (factor -> module .)
    COMA            reduce using rule 90 (factor -> module .)
    SEMICOLON       reduce using rule 90 (factor -> module .)
    LEFTBRACE       reduce using rule 90 (factor -> module .)


state 105

    (91) factor -> ID . addOperandId addTypeId
    (108) module -> ID . checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (94) addOperandId -> .
    (109) checkFunctionExists -> .

    MULTIPLY        reduce using rule 94 (addOperandId -> .)
    DIVIDE          reduce using rule 94 (addOperandId -> .)
    PLUS            reduce using rule 94 (addOperandId -> .)
    MINUS           reduce using rule 94 (addOperandId -> .)
    GT              reduce using rule 94 (addOperandId -> .)
    LT              reduce using rule 94 (addOperandId -> .)
    NOTEQUAL        reduce using rule 94 (addOperandId -> .)
    ISEQUAL         reduce using rule 94 (addOperandId -> .)
    EXCLAMATION     reduce using rule 94 (addOperandId -> .)
    QUESTION        reduce using rule 94 (addOperandId -> .)
    DOLLARSIGN      reduce using rule 94 (addOperandId -> .)
    AND             reduce using rule 94 (addOperandId -> .)
    OR              reduce using rule 94 (addOperandId -> .)
    RIGHTPAR        reduce using rule 94 (addOperandId -> .)
    COMA            reduce using rule 94 (addOperandId -> .)
    SEMICOLON       reduce using rule 94 (addOperandId -> .)
    LEFTBRACE       reduce using rule 94 (addOperandId -> .)
    LEFTPAR         reduce using rule 109 (checkFunctionExists -> .)

    addOperandId                   shift and go to state 133
    checkFunctionExists            shift and go to state 90

state 106

    (51) cst_PDT -> CST_INT . addTypeInt
    (54) addTypeInt -> .

    MULTIPLY        reduce using rule 54 (addTypeInt -> .)
    DIVIDE          reduce using rule 54 (addTypeInt -> .)
    PLUS            reduce using rule 54 (addTypeInt -> .)
    MINUS           reduce using rule 54 (addTypeInt -> .)
    GT              reduce using rule 54 (addTypeInt -> .)
    LT              reduce using rule 54 (addTypeInt -> .)
    NOTEQUAL        reduce using rule 54 (addTypeInt -> .)
    ISEQUAL         reduce using rule 54 (addTypeInt -> .)
    EXCLAMATION     reduce using rule 54 (addTypeInt -> .)
    QUESTION        reduce using rule 54 (addTypeInt -> .)
    DOLLARSIGN      reduce using rule 54 (addTypeInt -> .)
    AND             reduce using rule 54 (addTypeInt -> .)
    OR              reduce using rule 54 (addTypeInt -> .)
    RIGHTPAR        reduce using rule 54 (addTypeInt -> .)
    COMA            reduce using rule 54 (addTypeInt -> .)
    SEMICOLON       reduce using rule 54 (addTypeInt -> .)
    LEFTBRACE       reduce using rule 54 (addTypeInt -> .)

    addTypeInt                     shift and go to state 134

state 107

    (52) cst_PDT -> CST_FLOAT . addTypeFloat
    (55) addTypeFloat -> .

    MULTIPLY        reduce using rule 55 (addTypeFloat -> .)
    DIVIDE          reduce using rule 55 (addTypeFloat -> .)
    PLUS            reduce using rule 55 (addTypeFloat -> .)
    MINUS           reduce using rule 55 (addTypeFloat -> .)
    GT              reduce using rule 55 (addTypeFloat -> .)
    LT              reduce using rule 55 (addTypeFloat -> .)
    NOTEQUAL        reduce using rule 55 (addTypeFloat -> .)
    ISEQUAL         reduce using rule 55 (addTypeFloat -> .)
    EXCLAMATION     reduce using rule 55 (addTypeFloat -> .)
    QUESTION        reduce using rule 55 (addTypeFloat -> .)
    DOLLARSIGN      reduce using rule 55 (addTypeFloat -> .)
    AND             reduce using rule 55 (addTypeFloat -> .)
    OR              reduce using rule 55 (addTypeFloat -> .)
    RIGHTPAR        reduce using rule 55 (addTypeFloat -> .)
    COMA            reduce using rule 55 (addTypeFloat -> .)
    SEMICOLON       reduce using rule 55 (addTypeFloat -> .)
    LEFTBRACE       reduce using rule 55 (addTypeFloat -> .)

    addTypeFloat                   shift and go to state 135

state 108

    (53) cst_PDT -> CST_CHAR . addTypeChar
    (56) addTypeChar -> .

    MULTIPLY        reduce using rule 56 (addTypeChar -> .)
    DIVIDE          reduce using rule 56 (addTypeChar -> .)
    PLUS            reduce using rule 56 (addTypeChar -> .)
    MINUS           reduce using rule 56 (addTypeChar -> .)
    GT              reduce using rule 56 (addTypeChar -> .)
    LT              reduce using rule 56 (addTypeChar -> .)
    NOTEQUAL        reduce using rule 56 (addTypeChar -> .)
    ISEQUAL         reduce using rule 56 (addTypeChar -> .)
    EXCLAMATION     reduce using rule 56 (addTypeChar -> .)
    QUESTION        reduce using rule 56 (addTypeChar -> .)
    DOLLARSIGN      reduce using rule 56 (addTypeChar -> .)
    AND             reduce using rule 56 (addTypeChar -> .)
    OR              reduce using rule 56 (addTypeChar -> .)
    RIGHTPAR        reduce using rule 56 (addTypeChar -> .)
    COMA            reduce using rule 56 (addTypeChar -> .)
    SEMICOLON       reduce using rule 56 (addTypeChar -> .)
    LEFTBRACE       reduce using rule 56 (addTypeChar -> .)

    addTypeChar                    shift and go to state 136

state 109

    (18) if -> IF LEFTPAR Expression2 . RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ

    RIGHTPAR        shift and go to state 137


state 110

    (95) read -> READ LEFTPAR id_list . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 138


state 111

    (96) id_list -> ID . addRead id_listFunction
    (99) addRead -> .

    COMA            reduce using rule 99 (addRead -> .)
    RIGHTPAR        reduce using rule 99 (addRead -> .)

    addRead                        shift and go to state 139

state 112

    (100) print -> PRINT LEFTPAR printFunction . RIGHTPAR SEMICOLON

    RIGHTPAR        shift and go to state 140


state 113

    (101) printFunction -> print_param . COMA printFunction2
    (102) printFunction -> print_param .

    COMA            shift and go to state 141
    RIGHTPAR        reduce using rule 102 (printFunction -> print_param .)


state 114

    (105) print_param -> Expression2 . addPrint
    (104) addPrint -> .

    COMA            reduce using rule 104 (addPrint -> .)
    RIGHTPAR        reduce using rule 104 (addPrint -> .)

    addPrint                       shift and go to state 142

state 115

    (106) print_param -> CST_STRING . addPrintString
    (107) addPrintString -> .

    COMA            reduce using rule 107 (addPrintString -> .)
    RIGHTPAR        reduce using rule 107 (addPrintString -> .)

    addPrintString                 shift and go to state 143

state 116

    (10) assignment -> ID EQUAL Expression2 . SEMICOLON

    SEMICOLON       shift and go to state 144


state 117

    (108) module -> ID checkFunctionExists generateERASize . LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 145


state 118

    (24) for -> FOR forAssignment TO . pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (25) pushJumpFor -> .

    LEFTPAR         reduce using rule 25 (pushJumpFor -> .)
    ID              reduce using rule 25 (pushJumpFor -> .)
    CST_INT         reduce using rule 25 (pushJumpFor -> .)
    CST_FLOAT       reduce using rule 25 (pushJumpFor -> .)
    CST_CHAR        reduce using rule 25 (pushJumpFor -> .)

    pushJumpFor                    shift and go to state 146

state 119

    (28) forAssignment -> ID EQUAL . CST_INT

    CST_INT         shift and go to state 147


state 120

    (33) while -> WHILE pushLoop LEFTPAR . Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    Expression2                    shift and go to state 148
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 121

    (42) function -> functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement . RIGHTBRACE

    RIGHTBRACE      shift and go to state 149


state 122

    (88) factor -> LEFTPAR Expression2 . RIGHTPAR

    RIGHTPAR        shift and go to state 150


state 123

    (17) return -> RETURN LEFTPAR Expression2 RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 151


state 124

    (58) Expression2 -> Expression3 evaluateExp2 . Expression22 Expression2Nested
    (60) Expression2 -> Expression3 evaluateExp2 .
    (64) Expression22 -> . AND addOperator
    (65) Expression22 -> . OR addOperator

    RIGHTPAR        reduce using rule 60 (Expression2 -> Expression3 evaluateExp2 .)
    COMA            reduce using rule 60 (Expression2 -> Expression3 evaluateExp2 .)
    SEMICOLON       reduce using rule 60 (Expression2 -> Expression3 evaluateExp2 .)
    LEFTBRACE       reduce using rule 60 (Expression2 -> Expression3 evaluateExp2 .)
    AND             shift and go to state 153
    OR              shift and go to state 154

    Expression22                   shift and go to state 152

state 125

    (59) Expression2 -> Expression3 opMatrix .

    RIGHTPAR        reduce using rule 59 (Expression2 -> Expression3 opMatrix .)
    COMA            reduce using rule 59 (Expression2 -> Expression3 opMatrix .)
    SEMICOLON       reduce using rule 59 (Expression2 -> Expression3 opMatrix .)
    LEFTBRACE       reduce using rule 59 (Expression2 -> Expression3 opMatrix .)


state 126

    (73) opMatrix -> EXCLAMATION . addOperator
    (87) addOperator -> .

    RIGHTPAR        reduce using rule 87 (addOperator -> .)
    COMA            reduce using rule 87 (addOperator -> .)
    SEMICOLON       reduce using rule 87 (addOperator -> .)
    LEFTBRACE       reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 155

state 127

    (74) opMatrix -> QUESTION . addOperator
    (87) addOperator -> .

    RIGHTPAR        reduce using rule 87 (addOperator -> .)
    COMA            reduce using rule 87 (addOperator -> .)
    SEMICOLON       reduce using rule 87 (addOperator -> .)
    LEFTBRACE       reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 156

state 128

    (75) opMatrix -> DOLLARSIGN . addOperator
    (87) addOperator -> .

    RIGHTPAR        reduce using rule 87 (addOperator -> .)
    COMA            reduce using rule 87 (addOperator -> .)
    SEMICOLON       reduce using rule 87 (addOperator -> .)
    LEFTBRACE       reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 157

state 129

    (66) Expression3 -> exp evaluateExp3 . Expression33 exp evaluateExp3
    (67) Expression3 -> exp evaluateExp3 .
    (68) Expression33 -> . GT addOperator
    (69) Expression33 -> . LT addOperator
    (70) Expression33 -> . NOTEQUAL addOperator
    (71) Expression33 -> . ISEQUAL addOperator

    EXCLAMATION     reduce using rule 67 (Expression3 -> exp evaluateExp3 .)
    QUESTION        reduce using rule 67 (Expression3 -> exp evaluateExp3 .)
    DOLLARSIGN      reduce using rule 67 (Expression3 -> exp evaluateExp3 .)
    AND             reduce using rule 67 (Expression3 -> exp evaluateExp3 .)
    OR              reduce using rule 67 (Expression3 -> exp evaluateExp3 .)
    RIGHTPAR        reduce using rule 67 (Expression3 -> exp evaluateExp3 .)
    COMA            reduce using rule 67 (Expression3 -> exp evaluateExp3 .)
    SEMICOLON       reduce using rule 67 (Expression3 -> exp evaluateExp3 .)
    LEFTBRACE       reduce using rule 67 (Expression3 -> exp evaluateExp3 .)
    GT              shift and go to state 159
    LT              shift and go to state 160
    NOTEQUAL        shift and go to state 161
    ISEQUAL         shift and go to state 162

    Expression33                   shift and go to state 158

state 130

    (76) exp -> term evaluateTerm . expFunction
    (77) exp -> term evaluateTerm .
    (79) expFunction -> . PLUS addOperator exp
    (80) expFunction -> . MINUS addOperator exp

    GT              reduce using rule 77 (exp -> term evaluateTerm .)
    LT              reduce using rule 77 (exp -> term evaluateTerm .)
    NOTEQUAL        reduce using rule 77 (exp -> term evaluateTerm .)
    ISEQUAL         reduce using rule 77 (exp -> term evaluateTerm .)
    EXCLAMATION     reduce using rule 77 (exp -> term evaluateTerm .)
    QUESTION        reduce using rule 77 (exp -> term evaluateTerm .)
    DOLLARSIGN      reduce using rule 77 (exp -> term evaluateTerm .)
    AND             reduce using rule 77 (exp -> term evaluateTerm .)
    OR              reduce using rule 77 (exp -> term evaluateTerm .)
    RIGHTPAR        reduce using rule 77 (exp -> term evaluateTerm .)
    COMA            reduce using rule 77 (exp -> term evaluateTerm .)
    SEMICOLON       reduce using rule 77 (exp -> term evaluateTerm .)
    LEFTBRACE       reduce using rule 77 (exp -> term evaluateTerm .)
    PLUS            shift and go to state 164
    MINUS           shift and go to state 165

    expFunction                    shift and go to state 163

state 131

    (82) term -> factor evaluateFactor . termFunction
    (83) term -> factor evaluateFactor .
    (85) termFunction -> . MULTIPLY addOperator term
    (86) termFunction -> . DIVIDE addOperator term

    PLUS            reduce using rule 83 (term -> factor evaluateFactor .)
    MINUS           reduce using rule 83 (term -> factor evaluateFactor .)
    GT              reduce using rule 83 (term -> factor evaluateFactor .)
    LT              reduce using rule 83 (term -> factor evaluateFactor .)
    NOTEQUAL        reduce using rule 83 (term -> factor evaluateFactor .)
    ISEQUAL         reduce using rule 83 (term -> factor evaluateFactor .)
    EXCLAMATION     reduce using rule 83 (term -> factor evaluateFactor .)
    QUESTION        reduce using rule 83 (term -> factor evaluateFactor .)
    DOLLARSIGN      reduce using rule 83 (term -> factor evaluateFactor .)
    AND             reduce using rule 83 (term -> factor evaluateFactor .)
    OR              reduce using rule 83 (term -> factor evaluateFactor .)
    RIGHTPAR        reduce using rule 83 (term -> factor evaluateFactor .)
    COMA            reduce using rule 83 (term -> factor evaluateFactor .)
    SEMICOLON       reduce using rule 83 (term -> factor evaluateFactor .)
    LEFTBRACE       reduce using rule 83 (term -> factor evaluateFactor .)
    MULTIPLY        shift and go to state 167
    DIVIDE          shift and go to state 168

    termFunction                   shift and go to state 166

state 132

    (89) factor -> cst_PDT addOperandCst .

    MULTIPLY        reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    DIVIDE          reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    PLUS            reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    MINUS           reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    GT              reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    LT              reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    NOTEQUAL        reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    ISEQUAL         reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    EXCLAMATION     reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    QUESTION        reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    DOLLARSIGN      reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    AND             reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    OR              reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    RIGHTPAR        reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    COMA            reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    SEMICOLON       reduce using rule 89 (factor -> cst_PDT addOperandCst .)
    LEFTBRACE       reduce using rule 89 (factor -> cst_PDT addOperandCst .)


state 133

    (91) factor -> ID addOperandId . addTypeId
    (92) addTypeId -> .

    MULTIPLY        reduce using rule 92 (addTypeId -> .)
    DIVIDE          reduce using rule 92 (addTypeId -> .)
    PLUS            reduce using rule 92 (addTypeId -> .)
    MINUS           reduce using rule 92 (addTypeId -> .)
    GT              reduce using rule 92 (addTypeId -> .)
    LT              reduce using rule 92 (addTypeId -> .)
    NOTEQUAL        reduce using rule 92 (addTypeId -> .)
    ISEQUAL         reduce using rule 92 (addTypeId -> .)
    EXCLAMATION     reduce using rule 92 (addTypeId -> .)
    QUESTION        reduce using rule 92 (addTypeId -> .)
    DOLLARSIGN      reduce using rule 92 (addTypeId -> .)
    AND             reduce using rule 92 (addTypeId -> .)
    OR              reduce using rule 92 (addTypeId -> .)
    RIGHTPAR        reduce using rule 92 (addTypeId -> .)
    COMA            reduce using rule 92 (addTypeId -> .)
    SEMICOLON       reduce using rule 92 (addTypeId -> .)
    LEFTBRACE       reduce using rule 92 (addTypeId -> .)

    addTypeId                      shift and go to state 169

state 134

    (51) cst_PDT -> CST_INT addTypeInt .

    MULTIPLY        reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    DIVIDE          reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    PLUS            reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    MINUS           reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    GT              reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    LT              reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    NOTEQUAL        reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    ISEQUAL         reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    EXCLAMATION     reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    QUESTION        reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    DOLLARSIGN      reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    AND             reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    OR              reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    RIGHTPAR        reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    COMA            reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    SEMICOLON       reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)
    LEFTBRACE       reduce using rule 51 (cst_PDT -> CST_INT addTypeInt .)


state 135

    (52) cst_PDT -> CST_FLOAT addTypeFloat .

    MULTIPLY        reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    DIVIDE          reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    PLUS            reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    MINUS           reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    GT              reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    LT              reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    NOTEQUAL        reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    ISEQUAL         reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    EXCLAMATION     reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    QUESTION        reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    DOLLARSIGN      reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    AND             reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    OR              reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    RIGHTPAR        reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    COMA            reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    SEMICOLON       reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)
    LEFTBRACE       reduce using rule 52 (cst_PDT -> CST_FLOAT addTypeFloat .)


state 136

    (53) cst_PDT -> CST_CHAR addTypeChar .

    MULTIPLY        reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    DIVIDE          reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    PLUS            reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    MINUS           reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    GT              reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    LT              reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    NOTEQUAL        reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    ISEQUAL         reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    EXCLAMATION     reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    QUESTION        reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    DOLLARSIGN      reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    AND             reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    OR              reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    RIGHTPAR        reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    COMA            reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    SEMICOLON       reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)
    LEFTBRACE       reduce using rule 53 (cst_PDT -> CST_CHAR addTypeChar .)


state 137

    (18) if -> IF LEFTPAR Expression2 RIGHTPAR . createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (19) createJQif -> .

    THEN            reduce using rule 19 (createJQif -> .)

    createJQif                     shift and go to state 170

state 138

    (95) read -> READ LEFTPAR id_list RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 171


state 139

    (96) id_list -> ID addRead . id_listFunction
    (97) id_listFunction -> . COMA id_list
    (98) id_listFunction -> .

    COMA            shift and go to state 173
    RIGHTPAR        reduce using rule 98 (id_listFunction -> .)

    id_listFunction                shift and go to state 172

state 140

    (100) print -> PRINT LEFTPAR printFunction RIGHTPAR . SEMICOLON

    SEMICOLON       shift and go to state 174


state 141

    (101) printFunction -> print_param COMA . printFunction2
    (103) printFunction2 -> . printFunction
    (101) printFunction -> . print_param COMA printFunction2
    (102) printFunction -> . print_param
    (105) print_param -> . Expression2 addPrint
    (106) print_param -> . CST_STRING addPrintString
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    CST_STRING      shift and go to state 115
    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    print_param                    shift and go to state 113
    printFunction2                 shift and go to state 175
    printFunction                  shift and go to state 176
    Expression2                    shift and go to state 114
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 142

    (105) print_param -> Expression2 addPrint .

    COMA            reduce using rule 105 (print_param -> Expression2 addPrint .)
    RIGHTPAR        reduce using rule 105 (print_param -> Expression2 addPrint .)


state 143

    (106) print_param -> CST_STRING addPrintString .

    COMA            reduce using rule 106 (print_param -> CST_STRING addPrintString .)
    RIGHTPAR        reduce using rule 106 (print_param -> CST_STRING addPrintString .)


state 144

    (10) assignment -> ID EQUAL Expression2 SEMICOLON .

    RETURN          reduce using rule 10 (assignment -> ID EQUAL Expression2 SEMICOLON .)
    IF              reduce using rule 10 (assignment -> ID EQUAL Expression2 SEMICOLON .)
    COMMENT_TEXT    reduce using rule 10 (assignment -> ID EQUAL Expression2 SEMICOLON .)
    READ            reduce using rule 10 (assignment -> ID EQUAL Expression2 SEMICOLON .)
    PRINT           reduce using rule 10 (assignment -> ID EQUAL Expression2 SEMICOLON .)
    ID              reduce using rule 10 (assignment -> ID EQUAL Expression2 SEMICOLON .)
    FOR             reduce using rule 10 (assignment -> ID EQUAL Expression2 SEMICOLON .)
    WHILE           reduce using rule 10 (assignment -> ID EQUAL Expression2 SEMICOLON .)
    RIGHTBRACE      reduce using rule 10 (assignment -> ID EQUAL Expression2 SEMICOLON .)


state 145

    (108) module -> ID checkFunctionExists generateERASize LEFTPAR . moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (125) moduleFunction -> . Expression2 generateParam nextParam COMA moduleFunction
    (126) moduleFunction -> . Expression2 generateParam
    (127) moduleFunction -> .
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    RIGHTPAR        reduce using rule 127 (moduleFunction -> .)
    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    moduleFunction                 shift and go to state 177
    Expression2                    shift and go to state 178
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 146

    (24) for -> FOR forAssignment TO pushJumpFor . Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    Expression2                    shift and go to state 179
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 147

    (28) forAssignment -> ID EQUAL CST_INT .

    TO              reduce using rule 28 (forAssignment -> ID EQUAL CST_INT .)


state 148

    (33) while -> WHILE pushLoop LEFTPAR Expression2 . RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTPAR        shift and go to state 180


state 149

    (42) function -> functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE .

    FUNCTION        reduce using rule 42 (function -> functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE .)
    MAIN            reduce using rule 42 (function -> functionType ID addFuncToDir LEFTPAR param RIGHTPAR setParamLength LEFTBRACE declaration statement RIGHTBRACE .)


state 150

    (88) factor -> LEFTPAR Expression2 RIGHTPAR .

    MULTIPLY        reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    DIVIDE          reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    PLUS            reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    MINUS           reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    GT              reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    LT              reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    NOTEQUAL        reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    ISEQUAL         reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    EXCLAMATION     reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    QUESTION        reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    DOLLARSIGN      reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    AND             reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    OR              reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    RIGHTPAR        reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    COMA            reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    SEMICOLON       reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)
    LEFTBRACE       reduce using rule 88 (factor -> LEFTPAR Expression2 RIGHTPAR .)


state 151

    (17) return -> RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON .

    RIGHTBRACE      reduce using rule 17 (return -> RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON .)


state 152

    (58) Expression2 -> Expression3 evaluateExp2 Expression22 . Expression2Nested
    (61) Expression2Nested -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (62) Expression2Nested -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    Expression3                    shift and go to state 181
    Expression2Nested              shift and go to state 182
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 153

    (64) Expression22 -> AND . addOperator
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 183

state 154

    (65) Expression22 -> OR . addOperator
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 184

state 155

    (73) opMatrix -> EXCLAMATION addOperator .

    RIGHTPAR        reduce using rule 73 (opMatrix -> EXCLAMATION addOperator .)
    COMA            reduce using rule 73 (opMatrix -> EXCLAMATION addOperator .)
    SEMICOLON       reduce using rule 73 (opMatrix -> EXCLAMATION addOperator .)
    LEFTBRACE       reduce using rule 73 (opMatrix -> EXCLAMATION addOperator .)


state 156

    (74) opMatrix -> QUESTION addOperator .

    RIGHTPAR        reduce using rule 74 (opMatrix -> QUESTION addOperator .)
    COMA            reduce using rule 74 (opMatrix -> QUESTION addOperator .)
    SEMICOLON       reduce using rule 74 (opMatrix -> QUESTION addOperator .)
    LEFTBRACE       reduce using rule 74 (opMatrix -> QUESTION addOperator .)


state 157

    (75) opMatrix -> DOLLARSIGN addOperator .

    RIGHTPAR        reduce using rule 75 (opMatrix -> DOLLARSIGN addOperator .)
    COMA            reduce using rule 75 (opMatrix -> DOLLARSIGN addOperator .)
    SEMICOLON       reduce using rule 75 (opMatrix -> DOLLARSIGN addOperator .)
    LEFTBRACE       reduce using rule 75 (opMatrix -> DOLLARSIGN addOperator .)


state 158

    (66) Expression3 -> exp evaluateExp3 Expression33 . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    exp                            shift and go to state 185
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 159

    (68) Expression33 -> GT . addOperator
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 186

state 160

    (69) Expression33 -> LT . addOperator
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 187

state 161

    (70) Expression33 -> NOTEQUAL . addOperator
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 188

state 162

    (71) Expression33 -> ISEQUAL . addOperator
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 189

state 163

    (76) exp -> term evaluateTerm expFunction .

    GT              reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    LT              reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    NOTEQUAL        reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    ISEQUAL         reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    EXCLAMATION     reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    QUESTION        reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    DOLLARSIGN      reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    AND             reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    OR              reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    RIGHTPAR        reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    COMA            reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    SEMICOLON       reduce using rule 76 (exp -> term evaluateTerm expFunction .)
    LEFTBRACE       reduce using rule 76 (exp -> term evaluateTerm expFunction .)


state 164

    (79) expFunction -> PLUS . addOperator exp
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 190

state 165

    (80) expFunction -> MINUS . addOperator exp
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 191

state 166

    (82) term -> factor evaluateFactor termFunction .

    PLUS            reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    MINUS           reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    GT              reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    LT              reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    NOTEQUAL        reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    ISEQUAL         reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    EXCLAMATION     reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    QUESTION        reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    DOLLARSIGN      reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    AND             reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    OR              reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    RIGHTPAR        reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    COMA            reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    SEMICOLON       reduce using rule 82 (term -> factor evaluateFactor termFunction .)
    LEFTBRACE       reduce using rule 82 (term -> factor evaluateFactor termFunction .)


state 167

    (85) termFunction -> MULTIPLY . addOperator term
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 192

state 168

    (86) termFunction -> DIVIDE . addOperator term
    (87) addOperator -> .

    LEFTPAR         reduce using rule 87 (addOperator -> .)
    ID              reduce using rule 87 (addOperator -> .)
    CST_INT         reduce using rule 87 (addOperator -> .)
    CST_FLOAT       reduce using rule 87 (addOperator -> .)
    CST_CHAR        reduce using rule 87 (addOperator -> .)

    addOperator                    shift and go to state 193

state 169

    (91) factor -> ID addOperandId addTypeId .

    MULTIPLY        reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    DIVIDE          reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    PLUS            reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    MINUS           reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    GT              reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    LT              reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    NOTEQUAL        reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    ISEQUAL         reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    EXCLAMATION     reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    QUESTION        reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    DOLLARSIGN      reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    AND             reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    OR              reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    RIGHTPAR        reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    COMA            reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    SEMICOLON       reduce using rule 91 (factor -> ID addOperandId addTypeId .)
    LEFTBRACE       reduce using rule 91 (factor -> ID addOperandId addTypeId .)


state 170

    (18) if -> IF LEFTPAR Expression2 RIGHTPAR createJQif . THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ

    THEN            shift and go to state 194


state 171

    (95) read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .

    RETURN          reduce using rule 95 (read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .)
    IF              reduce using rule 95 (read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .)
    COMMENT_TEXT    reduce using rule 95 (read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .)
    READ            reduce using rule 95 (read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .)
    PRINT           reduce using rule 95 (read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .)
    ID              reduce using rule 95 (read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 95 (read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 95 (read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .)
    RIGHTBRACE      reduce using rule 95 (read -> READ LEFTPAR id_list RIGHTPAR SEMICOLON .)


state 172

    (96) id_list -> ID addRead id_listFunction .

    RIGHTPAR        reduce using rule 96 (id_list -> ID addRead id_listFunction .)


state 173

    (97) id_listFunction -> COMA . id_list
    (96) id_list -> . ID addRead id_listFunction

    ID              shift and go to state 111

    id_list                        shift and go to state 195

state 174

    (100) print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .

    RETURN          reduce using rule 100 (print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .)
    IF              reduce using rule 100 (print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .)
    COMMENT_TEXT    reduce using rule 100 (print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .)
    READ            reduce using rule 100 (print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .)
    PRINT           reduce using rule 100 (print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .)
    ID              reduce using rule 100 (print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 100 (print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 100 (print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .)
    RIGHTBRACE      reduce using rule 100 (print -> PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON .)


state 175

    (101) printFunction -> print_param COMA printFunction2 .

    RIGHTPAR        reduce using rule 101 (printFunction -> print_param COMA printFunction2 .)


state 176

    (103) printFunction2 -> printFunction .

    RIGHTPAR        reduce using rule 103 (printFunction2 -> printFunction .)


state 177

    (108) module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction . nullParam RIGHTPAR generateGosub SEMICOLON
    (111) nullParam -> .

    RIGHTPAR        reduce using rule 111 (nullParam -> .)

    nullParam                      shift and go to state 196

state 178

    (125) moduleFunction -> Expression2 . generateParam nextParam COMA moduleFunction
    (126) moduleFunction -> Expression2 . generateParam
    (113) generateParam -> .

    COMA            reduce using rule 113 (generateParam -> .)
    RIGHTPAR        reduce using rule 113 (generateParam -> .)

    generateParam                  shift and go to state 197

state 179

    (24) for -> FOR forAssignment TO pushJumpFor Expression2 . createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (26) createQuadFor -> .

    LEFTBRACE       reduce using rule 26 (createQuadFor -> .)

    createQuadFor                  shift and go to state 198

state 180

    (33) while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR . startLoop LEFTBRACE statement RIGHTBRACE endLoop
    (30) startLoop -> .

    LEFTBRACE       reduce using rule 30 (startLoop -> .)

    startLoop                      shift and go to state 199

state 181

    (61) Expression2Nested -> Expression3 . evaluateExp2 Expression22 Expression2Nested
    (62) Expression2Nested -> Expression3 . evaluateExp2
    (63) evaluateExp2 -> .

    AND             reduce using rule 63 (evaluateExp2 -> .)
    OR              reduce using rule 63 (evaluateExp2 -> .)
    RIGHTPAR        reduce using rule 63 (evaluateExp2 -> .)
    COMA            reduce using rule 63 (evaluateExp2 -> .)
    SEMICOLON       reduce using rule 63 (evaluateExp2 -> .)
    LEFTBRACE       reduce using rule 63 (evaluateExp2 -> .)

    evaluateExp2                   shift and go to state 200

state 182

    (58) Expression2 -> Expression3 evaluateExp2 Expression22 Expression2Nested .

    RIGHTPAR        reduce using rule 58 (Expression2 -> Expression3 evaluateExp2 Expression22 Expression2Nested .)
    COMA            reduce using rule 58 (Expression2 -> Expression3 evaluateExp2 Expression22 Expression2Nested .)
    SEMICOLON       reduce using rule 58 (Expression2 -> Expression3 evaluateExp2 Expression22 Expression2Nested .)
    LEFTBRACE       reduce using rule 58 (Expression2 -> Expression3 evaluateExp2 Expression22 Expression2Nested .)


state 183

    (64) Expression22 -> AND addOperator .

    LEFTPAR         reduce using rule 64 (Expression22 -> AND addOperator .)
    ID              reduce using rule 64 (Expression22 -> AND addOperator .)
    CST_INT         reduce using rule 64 (Expression22 -> AND addOperator .)
    CST_FLOAT       reduce using rule 64 (Expression22 -> AND addOperator .)
    CST_CHAR        reduce using rule 64 (Expression22 -> AND addOperator .)


state 184

    (65) Expression22 -> OR addOperator .

    LEFTPAR         reduce using rule 65 (Expression22 -> OR addOperator .)
    ID              reduce using rule 65 (Expression22 -> OR addOperator .)
    CST_INT         reduce using rule 65 (Expression22 -> OR addOperator .)
    CST_FLOAT       reduce using rule 65 (Expression22 -> OR addOperator .)
    CST_CHAR        reduce using rule 65 (Expression22 -> OR addOperator .)


state 185

    (66) Expression3 -> exp evaluateExp3 Expression33 exp . evaluateExp3
    (72) evaluateExp3 -> .

    EXCLAMATION     reduce using rule 72 (evaluateExp3 -> .)
    QUESTION        reduce using rule 72 (evaluateExp3 -> .)
    DOLLARSIGN      reduce using rule 72 (evaluateExp3 -> .)
    AND             reduce using rule 72 (evaluateExp3 -> .)
    OR              reduce using rule 72 (evaluateExp3 -> .)
    RIGHTPAR        reduce using rule 72 (evaluateExp3 -> .)
    COMA            reduce using rule 72 (evaluateExp3 -> .)
    SEMICOLON       reduce using rule 72 (evaluateExp3 -> .)
    LEFTBRACE       reduce using rule 72 (evaluateExp3 -> .)

    evaluateExp3                   shift and go to state 201

state 186

    (68) Expression33 -> GT addOperator .

    LEFTPAR         reduce using rule 68 (Expression33 -> GT addOperator .)
    ID              reduce using rule 68 (Expression33 -> GT addOperator .)
    CST_INT         reduce using rule 68 (Expression33 -> GT addOperator .)
    CST_FLOAT       reduce using rule 68 (Expression33 -> GT addOperator .)
    CST_CHAR        reduce using rule 68 (Expression33 -> GT addOperator .)


state 187

    (69) Expression33 -> LT addOperator .

    LEFTPAR         reduce using rule 69 (Expression33 -> LT addOperator .)
    ID              reduce using rule 69 (Expression33 -> LT addOperator .)
    CST_INT         reduce using rule 69 (Expression33 -> LT addOperator .)
    CST_FLOAT       reduce using rule 69 (Expression33 -> LT addOperator .)
    CST_CHAR        reduce using rule 69 (Expression33 -> LT addOperator .)


state 188

    (70) Expression33 -> NOTEQUAL addOperator .

    LEFTPAR         reduce using rule 70 (Expression33 -> NOTEQUAL addOperator .)
    ID              reduce using rule 70 (Expression33 -> NOTEQUAL addOperator .)
    CST_INT         reduce using rule 70 (Expression33 -> NOTEQUAL addOperator .)
    CST_FLOAT       reduce using rule 70 (Expression33 -> NOTEQUAL addOperator .)
    CST_CHAR        reduce using rule 70 (Expression33 -> NOTEQUAL addOperator .)


state 189

    (71) Expression33 -> ISEQUAL addOperator .

    LEFTPAR         reduce using rule 71 (Expression33 -> ISEQUAL addOperator .)
    ID              reduce using rule 71 (Expression33 -> ISEQUAL addOperator .)
    CST_INT         reduce using rule 71 (Expression33 -> ISEQUAL addOperator .)
    CST_FLOAT       reduce using rule 71 (Expression33 -> ISEQUAL addOperator .)
    CST_CHAR        reduce using rule 71 (Expression33 -> ISEQUAL addOperator .)


state 190

    (79) expFunction -> PLUS addOperator . exp
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    exp                            shift and go to state 202
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 191

    (80) expFunction -> MINUS addOperator . exp
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    exp                            shift and go to state 203
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 192

    (85) termFunction -> MULTIPLY addOperator . term
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    term                           shift and go to state 204
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 193

    (86) termFunction -> DIVIDE addOperator . term
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    term                           shift and go to state 205
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 194

    (18) if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN . LEFTBRACE statement RIGHTBRACE ifElse updateJQ

    LEFTBRACE       shift and go to state 206


state 195

    (97) id_listFunction -> COMA id_list .

    RIGHTPAR        reduce using rule 97 (id_listFunction -> COMA id_list .)


state 196

    (108) module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam . RIGHTPAR generateGosub SEMICOLON

    RIGHTPAR        shift and go to state 207


state 197

    (125) moduleFunction -> Expression2 generateParam . nextParam COMA moduleFunction
    (126) moduleFunction -> Expression2 generateParam .
    (114) nextParam -> .

    RIGHTPAR        reduce using rule 126 (moduleFunction -> Expression2 generateParam .)
    COMA            reduce using rule 114 (nextParam -> .)

    nextParam                      shift and go to state 208

state 198

    (24) for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor . LEFTBRACE statement RIGHTBRACE updateQuadFor

    LEFTBRACE       shift and go to state 209


state 199

    (33) while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop . LEFTBRACE statement RIGHTBRACE endLoop

    LEFTBRACE       shift and go to state 210


state 200

    (61) Expression2Nested -> Expression3 evaluateExp2 . Expression22 Expression2Nested
    (62) Expression2Nested -> Expression3 evaluateExp2 .
    (64) Expression22 -> . AND addOperator
    (65) Expression22 -> . OR addOperator

    RIGHTPAR        reduce using rule 62 (Expression2Nested -> Expression3 evaluateExp2 .)
    COMA            reduce using rule 62 (Expression2Nested -> Expression3 evaluateExp2 .)
    SEMICOLON       reduce using rule 62 (Expression2Nested -> Expression3 evaluateExp2 .)
    LEFTBRACE       reduce using rule 62 (Expression2Nested -> Expression3 evaluateExp2 .)
    AND             shift and go to state 153
    OR              shift and go to state 154

    Expression22                   shift and go to state 211

state 201

    (66) Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .

    EXCLAMATION     reduce using rule 66 (Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .)
    QUESTION        reduce using rule 66 (Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .)
    DOLLARSIGN      reduce using rule 66 (Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .)
    AND             reduce using rule 66 (Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .)
    OR              reduce using rule 66 (Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .)
    RIGHTPAR        reduce using rule 66 (Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .)
    COMA            reduce using rule 66 (Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .)
    SEMICOLON       reduce using rule 66 (Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .)
    LEFTBRACE       reduce using rule 66 (Expression3 -> exp evaluateExp3 Expression33 exp evaluateExp3 .)


state 202

    (79) expFunction -> PLUS addOperator exp .

    GT              reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    LT              reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    NOTEQUAL        reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    ISEQUAL         reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    EXCLAMATION     reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    QUESTION        reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    DOLLARSIGN      reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    AND             reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    OR              reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    RIGHTPAR        reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    COMA            reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    SEMICOLON       reduce using rule 79 (expFunction -> PLUS addOperator exp .)
    LEFTBRACE       reduce using rule 79 (expFunction -> PLUS addOperator exp .)


state 203

    (80) expFunction -> MINUS addOperator exp .

    GT              reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    LT              reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    NOTEQUAL        reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    ISEQUAL         reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    EXCLAMATION     reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    QUESTION        reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    DOLLARSIGN      reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    AND             reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    OR              reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    RIGHTPAR        reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    COMA            reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    SEMICOLON       reduce using rule 80 (expFunction -> MINUS addOperator exp .)
    LEFTBRACE       reduce using rule 80 (expFunction -> MINUS addOperator exp .)


state 204

    (85) termFunction -> MULTIPLY addOperator term .

    PLUS            reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    MINUS           reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    GT              reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    LT              reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    NOTEQUAL        reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    ISEQUAL         reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    EXCLAMATION     reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    QUESTION        reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    DOLLARSIGN      reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    AND             reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    OR              reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    RIGHTPAR        reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    COMA            reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    SEMICOLON       reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)
    LEFTBRACE       reduce using rule 85 (termFunction -> MULTIPLY addOperator term .)


state 205

    (86) termFunction -> DIVIDE addOperator term .

    PLUS            reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    MINUS           reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    GT              reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    LT              reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    NOTEQUAL        reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    ISEQUAL         reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    EXCLAMATION     reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    QUESTION        reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    DOLLARSIGN      reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    AND             reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    OR              reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    RIGHTPAR        reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    COMA            reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    SEMICOLON       reduce using rule 86 (termFunction -> DIVIDE addOperator term .)
    LEFTBRACE       reduce using rule 86 (termFunction -> DIVIDE addOperator term .)


state 206

    (18) if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE . statement RIGHTBRACE ifElse updateJQ
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    statement                      shift and go to state 212
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 207

    (108) module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR . generateGosub SEMICOLON
    (112) generateGosub -> .

    SEMICOLON       reduce using rule 112 (generateGosub -> .)

    generateGosub                  shift and go to state 213

state 208

    (125) moduleFunction -> Expression2 generateParam nextParam . COMA moduleFunction

    COMA            shift and go to state 214


state 209

    (24) for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE . statement RIGHTBRACE updateQuadFor
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    statement                      shift and go to state 215
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 210

    (33) while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE . statement RIGHTBRACE endLoop
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    statement                      shift and go to state 216
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 211

    (61) Expression2Nested -> Expression3 evaluateExp2 Expression22 . Expression2Nested
    (61) Expression2Nested -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (62) Expression2Nested -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    Expression3                    shift and go to state 181
    Expression2Nested              shift and go to state 217
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 212

    (18) if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement . RIGHTBRACE ifElse updateJQ

    RIGHTBRACE      shift and go to state 218


state 213

    (108) module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub . SEMICOLON

    SEMICOLON       shift and go to state 219


state 214

    (125) moduleFunction -> Expression2 generateParam nextParam COMA . moduleFunction
    (125) moduleFunction -> . Expression2 generateParam nextParam COMA moduleFunction
    (126) moduleFunction -> . Expression2 generateParam
    (127) moduleFunction -> .
    (58) Expression2 -> . Expression3 evaluateExp2 Expression22 Expression2Nested
    (59) Expression2 -> . Expression3 opMatrix
    (60) Expression2 -> . Expression3 evaluateExp2
    (66) Expression3 -> . exp evaluateExp3 Expression33 exp evaluateExp3
    (67) Expression3 -> . exp evaluateExp3
    (76) exp -> . term evaluateTerm expFunction
    (77) exp -> . term evaluateTerm
    (82) term -> . factor evaluateFactor termFunction
    (83) term -> . factor evaluateFactor
    (88) factor -> . LEFTPAR Expression2 RIGHTPAR
    (89) factor -> . cst_PDT addOperandCst
    (90) factor -> . module
    (91) factor -> . ID addOperandId addTypeId
    (51) cst_PDT -> . CST_INT addTypeInt
    (52) cst_PDT -> . CST_FLOAT addTypeFloat
    (53) cst_PDT -> . CST_CHAR addTypeChar
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON

    RIGHTPAR        reduce using rule 127 (moduleFunction -> .)
    LEFTPAR         shift and go to state 97
    ID              shift and go to state 105
    CST_INT         shift and go to state 106
    CST_FLOAT       shift and go to state 107
    CST_CHAR        shift and go to state 108

    Expression2                    shift and go to state 178
    moduleFunction                 shift and go to state 220
    Expression3                    shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    cst_PDT                        shift and go to state 103
    module                         shift and go to state 104

state 215

    (24) for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement . RIGHTBRACE updateQuadFor

    RIGHTBRACE      shift and go to state 221


state 216

    (33) while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement . RIGHTBRACE endLoop

    RIGHTBRACE      shift and go to state 222


state 217

    (61) Expression2Nested -> Expression3 evaluateExp2 Expression22 Expression2Nested .

    RIGHTPAR        reduce using rule 61 (Expression2Nested -> Expression3 evaluateExp2 Expression22 Expression2Nested .)
    COMA            reduce using rule 61 (Expression2Nested -> Expression3 evaluateExp2 Expression22 Expression2Nested .)
    SEMICOLON       reduce using rule 61 (Expression2Nested -> Expression3 evaluateExp2 Expression22 Expression2Nested .)
    LEFTBRACE       reduce using rule 61 (Expression2Nested -> Expression3 evaluateExp2 Expression22 Expression2Nested .)


state 218

    (18) if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE . ifElse updateJQ
    (21) ifElse -> . ELSE createJQelse LEFTBRACE statement RIGHTBRACE
    (22) ifElse -> .

    ELSE            shift and go to state 224
    RETURN          reduce using rule 22 (ifElse -> .)
    IF              reduce using rule 22 (ifElse -> .)
    COMMENT_TEXT    reduce using rule 22 (ifElse -> .)
    READ            reduce using rule 22 (ifElse -> .)
    PRINT           reduce using rule 22 (ifElse -> .)
    ID              reduce using rule 22 (ifElse -> .)
    FOR             reduce using rule 22 (ifElse -> .)
    WHILE           reduce using rule 22 (ifElse -> .)
    RIGHTBRACE      reduce using rule 22 (ifElse -> .)

    ifElse                         shift and go to state 223

state 219

    (108) module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .

    RETURN          reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    IF              reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    COMMENT_TEXT    reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    READ            reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    PRINT           reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    ID              reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    FOR             reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    WHILE           reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    RIGHTBRACE      reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    MULTIPLY        reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    DIVIDE          reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    PLUS            reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    MINUS           reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    GT              reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    LT              reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    NOTEQUAL        reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    ISEQUAL         reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    EXCLAMATION     reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    QUESTION        reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    DOLLARSIGN      reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    AND             reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    OR              reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    RIGHTPAR        reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    COMA            reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    SEMICOLON       reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)
    LEFTBRACE       reduce using rule 108 (module -> ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON .)


state 220

    (125) moduleFunction -> Expression2 generateParam nextParam COMA moduleFunction .

    RIGHTPAR        reduce using rule 125 (moduleFunction -> Expression2 generateParam nextParam COMA moduleFunction .)


state 221

    (24) for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE . updateQuadFor
    (27) updateQuadFor -> .

    RETURN          reduce using rule 27 (updateQuadFor -> .)
    IF              reduce using rule 27 (updateQuadFor -> .)
    COMMENT_TEXT    reduce using rule 27 (updateQuadFor -> .)
    READ            reduce using rule 27 (updateQuadFor -> .)
    PRINT           reduce using rule 27 (updateQuadFor -> .)
    ID              reduce using rule 27 (updateQuadFor -> .)
    FOR             reduce using rule 27 (updateQuadFor -> .)
    WHILE           reduce using rule 27 (updateQuadFor -> .)
    RIGHTBRACE      reduce using rule 27 (updateQuadFor -> .)

    updateQuadFor                  shift and go to state 225

state 222

    (33) while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE . endLoop
    (31) endLoop -> .

    RETURN          reduce using rule 31 (endLoop -> .)
    IF              reduce using rule 31 (endLoop -> .)
    COMMENT_TEXT    reduce using rule 31 (endLoop -> .)
    READ            reduce using rule 31 (endLoop -> .)
    PRINT           reduce using rule 31 (endLoop -> .)
    ID              reduce using rule 31 (endLoop -> .)
    FOR             reduce using rule 31 (endLoop -> .)
    WHILE           reduce using rule 31 (endLoop -> .)
    RIGHTBRACE      reduce using rule 31 (endLoop -> .)

    endLoop                        shift and go to state 226

state 223

    (18) if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse . updateJQ
    (20) updateJQ -> .

    RETURN          reduce using rule 20 (updateJQ -> .)
    IF              reduce using rule 20 (updateJQ -> .)
    COMMENT_TEXT    reduce using rule 20 (updateJQ -> .)
    READ            reduce using rule 20 (updateJQ -> .)
    PRINT           reduce using rule 20 (updateJQ -> .)
    ID              reduce using rule 20 (updateJQ -> .)
    FOR             reduce using rule 20 (updateJQ -> .)
    WHILE           reduce using rule 20 (updateJQ -> .)
    RIGHTBRACE      reduce using rule 20 (updateJQ -> .)

    updateJQ                       shift and go to state 227

state 224

    (21) ifElse -> ELSE . createJQelse LEFTBRACE statement RIGHTBRACE
    (23) createJQelse -> .

    LEFTBRACE       reduce using rule 23 (createJQelse -> .)

    createJQelse                   shift and go to state 228

state 225

    (24) for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .

    RETURN          reduce using rule 24 (for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .)
    IF              reduce using rule 24 (for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .)
    COMMENT_TEXT    reduce using rule 24 (for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .)
    READ            reduce using rule 24 (for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .)
    PRINT           reduce using rule 24 (for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .)
    ID              reduce using rule 24 (for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .)
    FOR             reduce using rule 24 (for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .)
    WHILE           reduce using rule 24 (for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .)
    RIGHTBRACE      reduce using rule 24 (for -> FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor .)


state 226

    (33) while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .

    RETURN          reduce using rule 33 (while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .)
    IF              reduce using rule 33 (while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .)
    COMMENT_TEXT    reduce using rule 33 (while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .)
    READ            reduce using rule 33 (while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .)
    PRINT           reduce using rule 33 (while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .)
    ID              reduce using rule 33 (while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .)
    FOR             reduce using rule 33 (while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .)
    WHILE           reduce using rule 33 (while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .)
    RIGHTBRACE      reduce using rule 33 (while -> WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop .)


state 227

    (18) if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .

    RETURN          reduce using rule 18 (if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .)
    IF              reduce using rule 18 (if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .)
    COMMENT_TEXT    reduce using rule 18 (if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .)
    READ            reduce using rule 18 (if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .)
    PRINT           reduce using rule 18 (if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .)
    ID              reduce using rule 18 (if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .)
    FOR             reduce using rule 18 (if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .)
    WHILE           reduce using rule 18 (if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .)
    RIGHTBRACE      reduce using rule 18 (if -> IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ .)


state 228

    (21) ifElse -> ELSE createJQelse . LEFTBRACE statement RIGHTBRACE

    LEFTBRACE       shift and go to state 229


state 229

    (21) ifElse -> ELSE createJQelse LEFTBRACE . statement RIGHTBRACE
    (115) statement -> . return
    (116) statement -> . if statement
    (117) statement -> . comment statement
    (118) statement -> . read statement
    (119) statement -> . print statement
    (120) statement -> . assignment statement
    (121) statement -> . module statement
    (122) statement -> . for statement
    (123) statement -> . while statement
    (124) statement -> .
    (17) return -> . RETURN LEFTPAR Expression2 RIGHTPAR SEMICOLON
    (18) if -> . IF LEFTPAR Expression2 RIGHTPAR createJQif THEN LEFTBRACE statement RIGHTBRACE ifElse updateJQ
    (32) comment -> . COMMENT_TEXT
    (95) read -> . READ LEFTPAR id_list RIGHTPAR SEMICOLON
    (100) print -> . PRINT LEFTPAR printFunction RIGHTPAR SEMICOLON
    (10) assignment -> . ID EQUAL Expression2 SEMICOLON
    (108) module -> . ID checkFunctionExists generateERASize LEFTPAR moduleFunction nullParam RIGHTPAR generateGosub SEMICOLON
    (24) for -> . FOR forAssignment TO pushJumpFor Expression2 createQuadFor LEFTBRACE statement RIGHTBRACE updateQuadFor
    (33) while -> . WHILE pushLoop LEFTPAR Expression2 RIGHTPAR startLoop LEFTBRACE statement RIGHTBRACE endLoop

    RIGHTBRACE      reduce using rule 124 (statement -> .)
    RETURN          shift and go to state 63
    IF              shift and go to state 64
    COMMENT_TEXT    shift and go to state 65
    READ            shift and go to state 66
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    FOR             shift and go to state 69
    WHILE           shift and go to state 70

    statement                      shift and go to state 230
    return                         shift and go to state 54
    if                             shift and go to state 55
    comment                        shift and go to state 56
    read                           shift and go to state 57
    print                          shift and go to state 58
    assignment                     shift and go to state 59
    module                         shift and go to state 60
    for                            shift and go to state 61
    while                          shift and go to state 62

state 230

    (21) ifElse -> ELSE createJQelse LEFTBRACE statement . RIGHTBRACE

    RIGHTBRACE      shift and go to state 231


state 231

    (21) ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .

    RETURN          reduce using rule 21 (ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .)
    IF              reduce using rule 21 (ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .)
    COMMENT_TEXT    reduce using rule 21 (ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .)
    READ            reduce using rule 21 (ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .)
    PRINT           reduce using rule 21 (ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .)
    ID              reduce using rule 21 (ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .)
    FOR             reduce using rule 21 (ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .)
    WHILE           reduce using rule 21 (ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .)
    RIGHTBRACE      reduce using rule 21 (ifElse -> ELSE createJQelse LEFTBRACE statement RIGHTBRACE .)

